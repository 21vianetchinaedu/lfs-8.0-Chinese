<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content=
        "application/xhtml+xml; charset=utf-8" />
        <title>
            5.2.&nbsp;工具链技术说明
        </title>
        <link rel="stylesheet" type="text/css" href="../stylesheets/lfs.css" />
        <meta name="generator" content="DocBook XSL Stylesheets V1.78.1" />
        <link rel="stylesheet" href="../stylesheets/lfs-print.css" type=
        "text/css" media="print" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    </head>
    <body class="lfs" id="lfs-8.0">
        <div class="navheader">
            <h4>
                Linux From Scratch - Version 8.0
            </h4>
            <h3>
                第五章&nbsp;构建临时系统
            </h3>
            <ul>
                <li class="prev">
                    <a accesskey="p" href="introduction.html" title=
                    "简介">上一页</a>
                    <p>
                    简介
                    </p>
                </li>
                <li class="next">
                    <a accesskey="n" href="generalinstructions.html" title=
                    "通用编译指南">下一页</a>
                    <p>
                    通用编译指南
                    </p>
                </li>
                <li class="up">
                    <a accesskey="u" href="chapter05.html" title=
                    "第五章&nbsp;构建临时系统">返回</a>
                </li>
                <li class="home">
                    <a accesskey="h" href="../index.html" title=
                    "Linux From Scratch - Version 8.0 ">首页</a>
                </li>
            </ul>
        </div>
        <div class="sect1" lang="en" xml:lang="en">
            <h1 class="sect1">
                <a id="ch-tools-toolchaintechnotes" name=
                "ch-tools-toolchaintechnotes"></a>5.2 工具链技术说明
            </h1>
            <p>
            这部分解释了隐藏在整体构建方法背后的一些基本原理以及技术细节，你不需要立即吃透这部分的所有内容，你将会在实际构建过程中更清晰地理解这部分内容。此外，你还可以在构建系统的同时随时随地查阅本小节内容。
            <!--This section explains some of the rationale and technical details-->
            <!--behind the overall build method. It is not essential to immediately-->
            <!--understand everything in this section. Most of this information will-->
            <!--be clearer after performing an actual build. This section can be-->
            <!--referred to at any time during the process.-->
            </p>
            <p>
            <a class="xref" href="chapter05.html" title="第五章&nbsp;构建临时系统">第五章</a>的总体目标是生成一个临时环境，该环境包含了一个大家都觉得很完善的独立于主系统的工具集。你可以通过使用 <span class="command"><strong>chroot</strong></span> 命令，将接下来几章节的命令包含在此环境中，以此确保目标LFS系统能够干净且无故障地生成。生成该构建过程是为了在给新读者最小化风险的同时，提供的更多的教育价值。
            <!--The overall goal of <a class="xref" href="chapter05.html" title=-->
            <!--"Chapter&nbsp;5.&nbsp;Constructing a Temporary System">Chapter 5</a>-->
            <!--is to produce a temporary area that contains a known-good set of-->
            <!--tools that can be isolated from the host system. By using-->
            <!--<span class="command"><strong>chroot</strong></span>, the commands in-->
            <!--the remaining chapters will be contained within that environment,-->
            <!--ensuring a clean, trouble-free build of the target LFS system. The-->
            <!--build process has been designed to minimize the risks for new readers-->
            <!--and to provide the most educational value at the same time.-->
            </p>
            <div class="admon note">
                <img alt="[Note]" src="../images/note.png" />
                <h3>
                    注意
                </h3>
                <p>
                在继续阅读之前，请留意工作平台的名称，它通常以目标三元组（译者注：形如“硬件平台-供应商-操作系统”称为目标三元组，比如x86_64-linux-gnu）的方式呈现。目标三元组名称可以很轻松地通过 <span class="command"><strong>config.guess</strong></span> 脚本来获取 ，很多软件的源码包都附带这个脚本。解压Binutils源码包并且执行脚本： <strong class="userinput"><code>./config.guess</code></strong> 就可以在终端看到工作平台的名称输出。比如说，搭载32位 Intel 处理器的电脑上就会输出 <span class="emphasis"><em>i686-pc-linux-gnu</em></span> ，而搭载64位处理器的电脑则会输出 <span class="emphasis"><em>x86_64-pc-linux-gnu</em></span>。
                <!--Before continuing, be aware of the name of the working platform,-->
                <!--often referred to as the target triplet. A simple way to determine-->
                <!--the name of the target triplet is to run the <span class=-->
                <!--"command"><strong>config.guess</strong></span> script that comes-->
                <!--with the source for many packages. Unpack the Binutils sources and-->
                <!--run the script: <strong class=-->
                <!--"userinput"><code>./config.guess</code></strong> and note the-->
                <!--output. For example, for a 32-bit Intel processor the output will-->
                <!--be <span class="emphasis"><em>i686-pc-linux-gnu</em></span>. On a-->
                <!--64-bit system it will be <span class=-->
                <!--"emphasis"><em>x86_64-pc-linux-gnu</em></span>.-->
                </p>
                <p>
                同时也请留意该平台的动态链接器的名称，通常它被称为动态加载器（请不要与Binutil中的动态链接器 <span class="command"><strong>ld</strong></span> 混淆）。该动态链接器由Glibc提供，它负责寻找并加载程序所需要的共享库，为程序运行做准备，并运行它。搭载32位Intel处理器的机器上动态链接器的名称为 <code class="filename">ld-linux.so.2</code> (64位系统上的名称为 <code class="filename">ld-linux-x86-64.so.2</code> ) 。如果你想要得到确定可靠的动态链接器名称，你可以在宿主系统上运行命令 <strong class="userinput"><code>readelf -l &lt;二进制文件名&gt; | grep interpreter</code></strong> 来检查任意二进制文件，并观察其输出。你可以在 Glibc 源码树根目录下的shlib-versions文件中找到所有平台的权威参考。
                <!--Also be aware of the name of the platform's dynamic linker, often-->
                <!--referred to as the dynamic loader (not to be confused with the-->
                <!--standard linker <span class="command"><strong>ld</strong></span>-->
                <!--that is part of Binutils). The dynamic linker provided by Glibc-->
                <!--finds and loads the shared libraries needed by a program, prepares-->
                <!--the program to run, and then runs it. The name of the dynamic-->
                <!--linker for a 32-bit Intel machine will be <code class=-->
                <!--"filename">ld-linux.so.2</code> (<code class=-->
                <!--"filename">ld-linux-x86-64.so.2</code> for 64-bit systems). A-->
                <!--sure-fire way to determine the name of the dynamic linker is to-->
                <!--inspect a random binary from the host system by running:-->
                <!--<strong class="userinput"><code>readelf -l &lt;name of binary&gt; |-->
                <!--grep interpreter</code></strong> and noting the output. The-->
                <!--authoritative reference covering all platforms is in the-->
                <!--<code class="filename">shlib-versions</code> file in the root of-->
                <!--the Glibc source tree.-->
                </p>
            </div>
            <p>
            以下是<a class="xref" href="chapter05.html" title="第五章&nbsp;构建临时系统">第五章</a>构建方法工作原理的几个关键技术要点。
            <!--Some key technical points of how the <a class="xref" href=-->
            <!--"chapter05.html" title=-->
            <!--"Chapter&nbsp;5.&nbsp;Constructing a Temporary System">Chapter 5</a>-->
            <!--build method works:-->
            </p>
            <div class="itemizedlist">
                <ul>
                    <li class="listitem">
                        <p>
                        为了确保第一次构建 binutils 和 GCC 时生成兼容的动态链接器和动态编译器，你需要微调工作平台的名称，微调方法是通过更改 <code class="envar">LFS_TGT</code> 变量来更改目标三元组的供应商字段。动态链接器和动态编译器生成的二进制文件与当前硬件兼容，而不是生成其它硬件架构上的二进制文件。
                        <!--Slightly adjusting the name of the working platform, by-->
                        <!--changing the "vendor" field target triplet by way of the-->
                        <!--<code class="envar">LFS_TGT</code> variable, ensures that the-->
                        <!--first build of Binutils and GCC produces a compatible-->
                        <!--cross-linker and cross-compiler. Instead of producing binaries-->
                        <!--for another architecture, the cross-linker and cross-compiler-->
                        <!--will produce binaries compatible with the current hardware.-->
                        </p>
                    </li>
                    <li class="listitem">
                        <p>
                        临时库是交叉编译生成的。因为交叉编译器本质上是不应该依赖于宿主系统的。通过减少将宿主系统所带的头文件以及库编译进新工具的机会，可以减少对于目标系统的潜在污染。交叉编译可以在64为硬件平台上同时编译出32位和64位的库。
                        <!--The temporary libraries are cross-compiled. Because a-->
                        <!--cross-compiler by its nature cannot rely on anything from its-->
                        <!--host system, this method removes potential contamination of the-->
                        <!--target system by lessening the chance of headers or libraries-->
                        <!--from the host being incorporated into the new tools.-->
                        <!--Cross-compilation also allows for the possibility of building-->
                        <!--both 32-bit and 64-bit libraries on 64-bit capable hardware.-->
                        </p>
                    </li>
                    <li class="listitem">
                        <p>
                        请谨慎操作 GCC 的源并告知编译器该使用的目标系统的动态链接器。
                        <!--Careful manipulation of the GCC source tells the compiler which-->
                        <!--target dynamic linker will be used.-->
                        </p>
                    </li>
                </ul>
            </div>
            <p>
            首先要安装Binutils，因为在执行GCC和Glibc的 <span class="command"><strong>configure</strong></span> 命令时，将会对汇编器和链接器进行多项功能测试，以此来确认哪些软件功能需要启用，哪些不要。这比我们最初意识到的还要重要。如果对GCC或者GLibc配置出错，将会导致工具链出现极其微小的错误，这种小错误也许可能要到整个发行版快构建完毕的时候才会显示出来。通常测试套件故障会在执行许多很多额外工作之前显示出来。

            <!--Binutils is installed first because the <span class=-->
            <!--"command"><strong>configure</strong></span> runs of both GCC and-->
        <!--Glibc perform various feature tests on the assembler and linker to-->
        <!--determine which software features to enable or disable. This is more-->
        <!--important than one might first realize. An incorrectly configured GCC-->
        <!--or Glibc can result in a subtly broken toolchain, where the impact of-->
        <!--such breakage might not show up until near the end of the build of an-->
        <!--entire distribution. A test suite failure will usually highlight this-->
        <!--error before too much additional work is performed.-->
            </p>
            <p>
            Binutila 把汇编器和链接器安装在两个位置，分别是 <code class="filename">/tools/bin</code> 和 <code class="filename">/tools/$LFS_TGT/bin</code> 。其中一个位置是指向另一个位置的硬链接。链接器的另外一个重要方面是它的库搜索顺序。你可以通过给 <span class="command"><strong>ld</strong></span> 传递 <em class=parameter"><code>--verbose</code></em> 参数来获取详细信息。例如，执行 <span class="userinput"><code>ld --verbose | grep SEARCH</code></span> 命令可以得到当前搜索路径和顺序。你还可以通过编译一个虚拟程序并将 <em class="parameter"><code>--verbose</code></em> 开关传递给链接器，来显示哪些文件由 <span class="command"><strong>ld</strong></span> 链接。例如，执行命令 <strong class="userinput"><code>gcc dummy.c -Wl,--verbose 2&gt;&amp;1 | grep succeeded</code></strong> 会成功显示在链接过程中打开的所有文件。

            </p>
            <p>
            下一个安装的包是GCC。我们可以看一个在它执行 <span class="command"><strong>configure</strong></span>的例子：
            </p>
            <pre class="screen">
<code class=
"computeroutput">checking what assembler to use... /tools/i686-lfs-linux-gnu/bin/as
checking what linker to use... /tools/i686-lfs-linux-gnu/bin/ld</code>
            </pre>
            <p>
            This is important for the reasons mentioned above. It also
            demonstrates that GCC's configure script does not search the PATH
            directories to find which tools to use. However, during the actual
            operation of <span class="command"><strong>gcc</strong></span>
            itself, the same search paths are not necessarily used. To find out
            which standard linker <span class=
            "command"><strong>gcc</strong></span> will use, run: <strong class=
            "userinput"><code>gcc -print-prog-name=ld</code></strong>.
            </p>
            <p>
            Detailed information can be obtained from <span class=
            "command"><strong>gcc</strong></span> by passing it the <em class=
            "parameter"><code>-v</code></em> command line option while compiling
        a dummy program. For example, <strong class="userinput"><code>gcc -v
                dummy.c</code></strong> will show detailed information about the
        preprocessor, compilation, and assembly stages, including
        <span class="command"><strong>gcc</strong></span>'s included search
        paths and their order.
            </p>
            <p>
            Next installed are sanitized Linux API headers. These allow the
            standard C library (Glibc) to interface with features that the Linux
            kernel will provide.
            </p>
            <p>
            The next package installed is Glibc. The most important
            considerations for building Glibc are the compiler, binary tools, and
            kernel headers. The compiler is generally not an issue since Glibc
            will always use the compiler relating to the <em class=
            "parameter"><code>--host</code></em> parameter passed to its
        configure script; e.g. in our case, the compiler will be <span class=
        "command"><strong>i686-lfs-linux-gnu-gcc</strong></span>. The binary
    tools and kernel headers can be a bit more complicated. Therefore,
    take no risks and use the available configure switches to enforce the
    correct selections. After the run of <span class=
    "command"><strong>configure</strong></span>, check the contents of
the <code class="filename">config.make</code> file in the
<code class="filename">glibc-build</code> directory for all important
details. Note the use of <em class=
"parameter"><code>CC="i686-lfs-gnu-gcc"</code></em> to control which
        binary tools are used and the use of the <em class=
        "parameter"><code>-nostdinc</code></em> and <em class=
        "parameter"><code>-isystem</code></em> flags to control the
    compiler's include search path. These items highlight an important
    aspect of the Glibc package&mdash;it is very self-sufficient in terms
    of its build machinery and generally does not rely on toolchain
    defaults.
            </p>
            <p>
            During the second pass of Binutils, we are able to utilize the
            <em class="parameter"><code>--with-lib-path</code></em> configure
            switch to control <span class="command"><strong>ld</strong></span>'s
            library search path.
            </p>
            <p>
            For the second pass of GCC, its sources also need to be modified to
            tell GCC to use the new dynamic linker. Failure to do so will result
            in the GCC programs themselves having the name of the dynamic linker
            from the host system's <code class="filename">/lib</code> directory
            embedded into them, which would defeat the goal of getting away from
            the host. From this point onwards, the core toolchain is
            self-contained and self-hosted. The remainder of the <a class="xref"
                                                                    href="chapter05.html" title=
                                                                    "Chapter&nbsp;5.&nbsp;Constructing a Temporary System">Chapter 5</a>
            packages all build against the new Glibc in <code class=
            "filename">/tools</code>.
            </p>
            <p>
            Upon entering the chroot environment in <a class="xref" href=
            "../chapter06/chapter06.html" title=
            "Chapter&nbsp;6.&nbsp;Installing Basic System Software">Chapter
            6</a>, the first major package to be installed is Glibc, due to its
        self-sufficient nature mentioned above. Once this Glibc is installed
        into <code class="filename">/usr</code>, we will perform a quick
        changeover of the toolchain defaults, and then proceed in building
        the rest of the target LFS system.
            </p>
        </div>
        <div class="navfooter">
            <ul>
                <li class="prev">
                    <a accesskey="p" href="introduction.html" title=
                    "简介">上一页</a>
                    <p>
                    简介
                    </p>
                </li>
                <li class="next">
                    <a accesskey="n" href="generalinstructions.html" title=
                    "通用编译指南">下一页</a>
                    <p>
                        通用编译指南
                    </p>
                </li>
                <li class="up">
                    <a accesskey="u" href="chapter05.html" title=
                    "第五章&nbsp;构建临时系统">返回</a>
                </li>
                <li class="home">
                    <a accesskey="h" href="../index.html" title=
                    "Linux From Scratch - Version 8.0 ">主页</a>
                </li>
            </ul>
        </div>
    </body>
</html>
